
# SYSDEV

## TL;DR

**GLOSSARY: Page 732-748; READ THIS FOR IMPORTANT TERMS AND SHIT**

* General Development concepts
	- Composition-structure **Page 468 - Component composition**
	- CheckOut 
	- Portability
	- Repository
	- Refactoring
	- Thick client
	- Regression testing
	- High cohesion / Low coupling (Sommerville fig 6.6)
* Architecture **Page 155-164 - Architectural patterns**
	- MVC **Page 153-155 - Architectural Views**
	- SOA **Page 501-505 - Software as a Service (SaaS)**
	- Client-server **Page 160-163 - Client-server Architecture**
	- Repository **Page 159-160 - Repository Architecture**
	- Layered **Page 157-159 - Layered Architecture**
	- Pipe & Filter **Page 163 - Pipe and Filter Architecture**
* Databases
	- Aggregation
* DevOps
* Extreme Programming **Page 64-72 - Extreme Programming**
	- Pair programming **Page 71 - Pair programming**

* RUP **Page 50-53 - The Rational Unified Process**
	- Iteration
	- Transition
* SCRUM **Page 72-77 - Agile project management**
	- Planning Poker
	- Sprint Retrospective Meeting
	- Milestone
* Testing **Page 210-224 - Development Testing**
	- Regression testing **Page 221-224 - Test-driven Development (TDD)**
	- Equivalence partitioning **Page 212-214**
	- White-box / Black-box testing **Page 215-216**
* Waterfall model **Page 29-36 - Software process models**
* V-model **Page 41-50 - Software validation**


## Methodologies

* Elaborate on SCRUM
* Describe the 4 steps of risk analysis
* Explain how one relates to risk analysis within:
	- RUP
	- Extreme Programming
* Explain phase-division, milestones and iterations within SCRUM and RUP
* Explain the relevance of the extreme programming practices pair programming, on-site customer and collective ownership in SCRUM and RUP 
* Argue for which three practices of XP you believe have the most influence on how maintenance of the software will be upon completion

## Models, Diagrams & Tools
* Gantt
* Use Case model
* Domain model
* Deployment diagram
* System sequence diagram (UML)
* Explain how a repository-based tool allows several programmers to work simultaneously on the same source code without versioning conflicts
	- Explain how size can be kept down even though tens of programmers may constantly be adding new code
* Object Oriented Analysis
* Burn Down Chart
